[["index.html", "Fundamentals of scRNASeq Analysis Prerequisites", " Fundamentals of scRNASeq Analysis Xinyi Lin, Gordon Qian, Joshua Ho contact: jwkho@hku.hk 2021-06-28 (updated: 2021-07-02) Prerequisites This is the teaching material for Session 2: Fundamentals of scRNASeq Analysis of 2021 Single Cell Workshop. Install packages Some packages used in this material can be installed from CRAN or Github: install.packages(&#39;Seurat&#39;) install.packages(&quot;patchwork&quot;) install.packages(&quot;dplyr&quot;) install.packages(&quot;ggplot2&quot;) Set working directory Setting a working directory first helps us read and save data in a easier way. To set a working directory: create a folder named R-workshop in your preferred directory create a data folder in the R-workshop from RStudio, use the menu to change your working directory under Session &gt; Set Working Directory &gt; Choose Directory choose the directory to R-workshop Or you can type in the console: setwd(&quot;/yourdirectory/R-workshop&quot;) For Windows, the command might look like : setwd(&quot;c:/yourdirectory/R-workshop&quot;) Download data Data used in this workshop are samples of human immune cells (PBMC) in either a resting or interferon-stimulated state(Kang et al. 2018). The original data comes from: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE96583. To prepare data for this workshop: download the Exp6_Kang.zip from: https://drive.google.com/drive/folders/1LuFpvH_LIZnzNYcITFuFP27WaggJZga1?usp=sharing unzip the file and put it in the data folder we create before. the structure of the data folder should be look like this: Acknowledgement Thanks everyone in Ho Lab who gives great comments/suggestions and contributes to this teaching material. References "],["background.html", "Chapter 1 Introduction to Single Cell Technology 1.1 Single cell RNA sequencing(scRNA-seq) 1.2 Cell isolation 1.3 Barcodes and Unique molecular identifiers(UMI)1 1.4 Summary of widely used scRNA-seq technologies", " Chapter 1 Introduction to Single Cell Technology 1.1 Single cell RNA sequencing(scRNA-seq) Single cell RNA sequencing(scRNA-seq) is a sequencing technology which can give us gene expression profile of more than 30,000 genes for more than 10,000 cells. Starting from tissue samples we get, we will get the analysis results after following processes. Figure 1.1: Single Cell Genome Sequencing Workflow(taken from Wiki). MDA: multiple displacement amplification 1.2 Cell isolation Droplet-based: tissue sample must be dissociated into suspension cells will be encapsulated into a water-in-oildroplet individually high-throughput and low cost related technologies: Drop-seq(Macosko et al. 2015), inDrop(Klein et al. 2015), Chromium 10X(Zheng et al. 2017) Non droplet-based: Smart-seq2(Ramsköld et al. 2012): manual cell picking with micro capillary pipettes CEL-seq(Hashimshony et al. 2012): individual cells are added to tubes; the first one introducing barcodes and pooling of RNA MARS-seq(Jaitin et al. 2014) is the first one using FACS to isolate single cells into individual wells, and the optimized version MARS-seq2(Keren-Shaul et al. 2019) came out with lower cost, improved reproducibility, reduced well-to-well contamination Following shows some common single cell isolaion techniques(Hwang, Lee, and Bang 2018). Figure 1.2: Single Cell Isolation For more information about different cell isolation techniques: (Hu et al. 2016) 1.3 Barcodes and Unique molecular identifiers(UMI)1 This part is modified based on the lecture note, Single Cell RNA-Seq - Introduction created by David Tse et.al. Paired-end sequencing outputs two fastq files corresponding to the 5 and 3 direction of sequencing. With this sequencing technology, the first read of the pair always coincides with the cell (barcode + UMI) part of the primer. Figure 1.3: Biased paired-end reads(David Tse et.al) Based on the obtained reads consisting of cell barcode, UMI and cDNA, we can estimate the transcript abundances. This allows the mapping algorithm to distinguish which sequences are barcodes and which are transcript sequences. Thus, it is important to recognize the library preparation chemistry used for sequencing in order to determine cell barcode and UMI barcode sequence length and location. We first group reads by cell barcode before aligning cDNA reads and counting unique molecules per cell per gene using the UMIs. Figure 1.4: Grouping barcodes to assign reads to cells(David Tse et.al) Analysis of the cell barcode and UMI is included in the alignment process, and we will introduce more in Chapter 2. **Quiz** 1. What is the difference between a cell barcode and UMI barcode? and what are their significance? 2. What are the lengths of the cell barcode and UMI barcode used in our dataset? 3. Are these barcodes located on the 5&#39; or 3&#39; read file? 1.4 Summary of widely used scRNA-seq technologies Following is a summary table from (Chen, Ning, and Shi 2019). It shows different features of widely used scRNA-seq technologies. Methods Transcript coverage UMI possibility Strand specific References Tang method Nearly full-length No No (Tang et al. 2009) Quartz-Seq Full-length No No (Sasagawa et al. 2013) SUPeR-seq Full-length No No (X. Fan et al. 2015) Smart-seq Full-length No No (Ramsköld et al. 2012) Smart-seq2 Full-length No No (Picelli et al. 2013) MATQ-seq Full-length Yes Yes (Sheng et al. 2017) STRT-seq STRT/C1 5-only Yes Yes (Islam et al. 2011) CEL-seq 3-only Yes Yes (Hashimshony et al. 2012) CEL-seq2 3-only Yes Yes (Hashimshony et al. 2016) MARS-seq 3-only Yes Yes (Jaitin et al. 2014) CytoSeq 3-only Yes Yes (H. C. Fan, Fu, and Fodor 2015) Drop-seq 3-only Yes Yes (Macosko et al. 2015) InDrop 3-only Yes Yes (Klein et al. 2015) Chromium 3-only Yes Yes (Zheng et al. 2017) SPLiT-seq 3-only Yes Yes (Rosenberg et al. 2018) sci-RNA-seq 3-only Yes Yes (Cao et al. 2017) Seq-Well 3-only Yes Yes (Gierahn et al. 2017) DroNC-seq 3-only Yes Yes (Habib et al. 2017) Quartz-Seq2 3-only Yes Yes (Sasagawa et al. 2018) References "],["raw2matrix.html", "Chapter 2 Pre-processing and QC 2.1 FASTQ file 2.2 Cell Ranger2 2.3 STARsolo 2.4 Doublets8", " Chapter 2 Pre-processing and QC 2.1 FASTQ file Raw RNA-sequencing data might be in a fastq file. It is a text-based format used for storing read sequences represented by single-letter codes. A sequence in FASTA format begins with a readID started with (@) symbol, then lines of sequence data, a separator which is simply a plus (+) sign, and the base call quality scores. It is represented in the following format: &gt;ReadID READ SEQUENCE + SEQUENCING QUALITY SCORES For more details about FASTQ files: https://sapac.support.illumina.com/bulletins/2016/04/fastq-files-explained.html Generally fastq files are pre-processed using quality control tools, such as FastQC. This outputs a series of metrics assessing the quality of sequence reads. Some of these metrics include: 1. Per base sequence quality 2. Per sequence quality scores 3. Per base sequence content 4. Per sequence GC content 5. Per base N content 6. Sequence Duplication Levels 7. Overrepresented Sequences 8. Adapter Content 9. Kmer Content For more details about FastQC: https://www.bioinformatics.babraham.ac.uk/projects/fastqc/ 2.2 Cell Ranger2 Figures and contents in this sub-chapter are modified from Cell Ranger Support Pages. Cell Ranger is a set of analysis pipelines that process Chromium single-cell data to align reads, generate feature-barcode matrices, perform clustering and other secondary analysis, and more. Some concepts: GEM well (formerly GEM group): A set of partitioned cells (Gelbeads-in-Emulsion) from a single 10x Chromium Chip channel. One or more sequencing libraries can be derived from a GEM well. Library (or Sequencing Library): A 10x-barcoded sequencing library prepared from a single GEM well. With Feature Barcode or V(D)J assays, it is possible to create multiple libraries from the same GEM well. The library types may include Gene Expression, Antibody Capture, CRISPR Guide Capture, TCR-enrichment, etc. Sequencing Run (or Flowcell): A flowcell containing data from one sequencing instrument run. 2.2.1 General workflow Single-cell data getting from Chromium 10X pipeline can be processed through following workflow using cellranger. Figure 2.1: Cellranger Workflow(taken from the cellranger website) 2.2.2 Output file3 Following the output folder we will get from cellranger. The outs folder contains the final pipeline output files which including what we want for downstream analysis. Figure 2.2: Overview of the folder generate from cellranger Figure 2.3: Overview of the outs folder Above is what we can find in the outs folder. It contains some summary information of the sequencing data, the annotated read sequences, and gene expression matrices we commonly work on. Following is some important output files we want to look at. Matrices Web Summary .html Secondary Analysis CSV BAM Molecule Info (h5) Loupe File (.cloupe) Matrices When sequencing, Chromium 10X not only sequences transcriptome, but also sequences any possible molecular. This leads to existence of background barcodes. Cell associated barcodes are those barcodes that cellranger believes are marking transcriptome coming from real cells instead of background. For different version of cellranger, different algorithms are used to detect cell associated barcodes. The general idea is that barcodes for cells should have significantly more transcript counts associated with them than the background barcodes. For more information: https://kb.10xgenomics.com/hc/en-us/articles/115003480523-How-are-barcodes-classified-as-cell-associated-. The cellranger pipeline outputs two types of feature-barcode matrices Unfiltered feature-barcode matrix: is stored under raw_feature_bc_matrix(1-1) folder. Including every barcode from the fixed list of known-good barcode sequences that has at least 1 read, which means it includes background and cell associated barcodes. Filtered feature-barcode matrix: is stored under filtered_feature_bc_matrix(1-2) folder. Including only detected cell associated barcodes. Both raw_feature_bc_matrix and filtered_feature_bc_matrix contains three files4. The matrix.mtx.gz file stores reads count as sparse matrices where each row indicates one gene in scRNA-seq data and each column indicates one cell. The information of row indices is stored in the features.tsv.gz file while the information of column indicates is stored in the barcodes.tsv.gz file. The features.tsv.gz file corresponds to row indices. In scRNA-seq data, features are actually genes. The features.tsv.gz file contains three columns: feature ID: gene_id in the annotation field of the reference GTF name: gene_name in the annotation field of the reference GTF. If no gene_name field is present in the reference GTF, gene name is equivalent to gene ID. type of feature: describe features&#39; types, can be one of Gene Expression, Antibody Capture, CRISPR, or CUSTOM. For scRNA-seq data, it will be Gene Expression. The barcodes.tsv.gz corresponds to column indices. It contains the barcode of each column. More details on the barcode sequence format are available in the barcoded BAM section. Web Summary .html A summary HTML file contains summary metrics and automated secondary analysis results. If an issue was detected during the pipeline run, an alert appears on this page. This html files includes two parts, SUMMARY and ANALYSIS. You can also click the ? in the top of each dashboard for more information on each metric. The SUMMARY metrics describe sequencing quality and various characteristics of the detected cells. It includes the number of cells detected, the mean reads per cell, and the median genes detected per cell are prominently displayed near the top of the page. Figure 2.4: Cells dashboard(modified from the cellranger website) The Barcode Rank Plot under the Cells dashboard shows the distribution of barcode counts and which barcodes were inferred to be associated with cells. The y-axis is the number of UMI counts mapped to each barcode and the x-axis is the number of barcodes below that value. A steep drop-off is indicative of good separation between the cell-associated barcodes and the barcodes associated with empty partitions. Barcodes can be determined to be cell-associated based on their UMI count or by their RNA profiles, therefore some regions of the graph can contain both cell-associated and background-associated barcodes. The color of the graph represents the local density of barcodes that are cell-associated. Figure 2.5: Sequencing and Mapping dashboards(modified from the cellranger website) Other numbers used for evaluation5: Estimated Number of Cells: 500-10,000 Mean Reads per Cell: 20,000 reads/cell minimum recommended reads per cell around 10,000 Valid barcodes: greater than 75% Q30 bases in RNA read: ideally greater than 65%6 Reads mapped confidently to transcriptome: ideally greater than 30% Reads mapped antisense to gene: ideally smaller than 10% The ANALYSIS metrics contains the automated secondary analysis including the following: A dimensional reduction analysis which projects the cells into a 2-D space (t-SNE) An automated clustering analysis which groups together cells that have similar expression profiles A list of genes that are differentially expressed between the selected clusters A plot showing the effect of decreased sequencing depth on observed library complexity A plot showing the effect of decreased sequencing depth on median genes per cell detected BAM The BAM file, contains information about mapped reads, in a binary compressed format. It is consisted of a optional header section and an alignment section. If there is a a header section, it is distinguished from the alignment section by @ in the first column and will be prior to the alignment section. When de-compressed into a SAM file, information is stored as a tab seperated table with some standard columns and some generated by the Cell Ranger software specifically. The Cell Ranger specific columns contains information related to BAM Barcode, BAM Alignment and Feature Barcode.7 The standard columns corresponds to: QNAME : read name (generally will include UMI barcode if applicable) FLAG : number tag indicating the type of alignment, link to explanation of all possible types RNAME : reference sequence name (i.e. chromosome read is mapped to). POS : leftmost mapping position MAPQ : Mapping quality CIGAR : string indicating the matching/mismatching parts of the read (may include soft-clipping). RNEXT : reference name of the mate/next read PNEXT : POS for mate/next read TLEN : Template length (length of reference region the read is mapped to) SEQ : read sequence QUAL : read quality BAM files can be viewed using SAMtools. samtools view output.bam To do trajectory analysis based on RNA velocity, bam file is needed. Molecule Info (h5) It is an HDF5 file containing per-molecule information for all molecules that contain a valid barcode and valid UMI and were assigned with high confidence to a gene or Feature Barcode. This HDF5 file contains data corresponding to the observed molecules, as well as data about the libraries and feature set(s) used. The structure of this file is: Figure 2.6: HDF5 File Hierarchy(taken from the cellranger website) Secondary Analysis CSV Several CSV files which contain automated secondary analysis results. It contains information about Dimensionality Reduction, t-SNE, UMAP, Clustering and Differential Expression. It is also visualized in the ANALYSIS metrics through Web Summary .html file. Loupe File (.cloupe) Loupe Browser is a desktop application that provides interactive visualization functionality to analyze data from different 10x Genomics solutions. It can help to Finding Cells of Interest, Finding Significant Genes, Identifying Cell Types, Exploring Substructure, Exploring Cell Subtypes, Integrated Gene Expression and V(D)J Analysis, Sharing Results. A Loupe file can be viewed through Loupe Browser. It is embedded with the following information: Gene expression information for cells in the sample. Various gene expression-based clustering information for the cells, including t-SNE and UMAP projections and differential gene expression. Gene annotation information from the transcriptome reference. 2.3 STARsolo The STARsolo(Kaminow, Yunusov, and Dobin 2021) is a analysis toool designed for droplet single cell RNA sequencing data (e.g. 10X Genomics Chromium System) built directly into STAR code. The inputs of STARsolo is a FASTQ file, and it can gives nearly identical gene counts in the same format as Cell Ranger but ~10 times faster. The STARsolo program outputs a large amount of files reflecting details of the read alignment process. We will only discuss some of the key files here. Figure 2.7: STARsolo Output The BAM file, contains information about mapped reads wichi is quiet similari to the BAM file generated through Cell Ranger. Alignment summary files, Features.stat and Summary.csv, contains information about basic mapping details. This can serve as an easy preliminary quality control check of the alignment process. The feature matrix file, matrix.mtx, contains information about the counts of genes mapped in each individual cell. The column names corresponds to each individual cell barcode, and the row names corresponds to all annotated genes. Due to the large size of this data, it is stored as a sparse matrix. Auxiliary files, barcodes.tsv and features.tsv, provide extra metadata important for downstream analysis. These files along with the matrix file serve the same role as Matrices part in Cell Ranger output and are required for analysis in gold standard scRNA-seq data analysis package, seurat. 2.4 Doublets8 Doublets are artificial libraries generated from two cells even though it is designed to be generated from only one cell. It usually arise due to errors in cell sorting or capture. Several experimental strategies can be used to remove doublets: based on natural genetic variation between different donor individuals(Kang et al. 2018). mark a subset of cells (e.g., all cells from one sample) with an antibody conjugated to a different oligonucleotide. Upon pooling, libraries that are observed to have different oligonucleotides are considered to be doublets and removed(Bach et al. 2017). infer doublets from the expression profiles alone based on computational approaches like simulation. References "],["downstream.html", "Chapter 3 Analysis Using Seurat 3.1 Seurat object 3.2 Setup the Seurat object 3.3 Standard pre-processing workflow 3.4 Perform linear dimensional reduction 3.5 Cluster the cells 3.6 Run non-linear dimensional reduction (UMAP/tSNE)", " Chapter 3 Analysis Using Seurat The contents in this chapter are adapted from Seurat - Guided Clustering Tutorial with little modification. The data we used is a 10k PBMC data getting from 10x Genomics website In this tutorial, we will learn how to Read 10X sequencing data and change it into a seurat object, QC and selecting cells for further analysis, Normalizing the data, Identification of highly variable features (feature selection), Scaling the data, Perform linear dimensional reduction and Visualization. 3.1 Seurat object 3.2 Setup the Seurat object library(dplyr) library(Seurat) library(patchwork) library(ggplot2) We start by reading in the data. Read10X_h5 The Read10X() function reads in the output of the cellranger pipeline from 10X, returning a unique molecular identified (UMI) count matrix. The values in this matrix represent the number of molecules for each feature (i.e. gene; row) that are detected in each cell (column). We next use the count matrix to create a Seurat object. The object serves as a container that contains both data (like the count matrix) and analysis (like PCA, or clustering results) for a single-cell dataset. For a technical discussion of the Seurat object structure, check out our GitHub Wiki. The sameple in GSM2560248 is the control group which is human immune cells (PBMC) in a resting state, while the sameple in GSM2560249 is the human immune cells (PBMC) in a interferon-stimulated state. # Load the PBMC dataset pbmc.data &lt;- Read10X_h5(&quot;./data/10k_PBMC.h5&quot;) # Initialize the Seurat object with the raw (non-normalized data). pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc10k&quot;, min.cells = 3, min.features = 200) pbmc ## An object of class Seurat ## 22432 features across 10813 samples within 1 assay ## Active assay: RNA (22432 features, 0 variable features) If we want to read data using the output of the cellranger pipeline from 10X directly, we can use Read10X() Read10X(data.dir) 3.3 Standard pre-processing workflow The steps below encompass the standard pre-processing workflow for scRNA-seq data in Seurat. These represent the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable features. 3.3.1 QC and selecting cells for further analysis Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics commonly used(Ilicic et al. 2016) by the community include The number of unique genes detected in each cell. Low-quality cells or empty droplets will often have very few genes Cell doublets or multiplets may exhibit an aberrantly high gene count Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes) The percentage of reads that map to the mitochondrial genome Low-quality / dying cells often exhibit extensive mitochondrial contamination We calculate mitochondrial QC metrics with the PercentageFeatureSet() function, which calculates the percentage of counts originating from a set of features We use the set of all genes starting with MT- as a set of mitochondrial genes # The [[ operator can add columns to object metadata. This is a great place to stash QC stats pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) The number of unique genes and total molecules are automatically calculated during CreateSeuratObject(). They are stored in the object meta data. # Show QC metrics for the first 5 cells in the control group head(pbmc@meta.data, 5) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACCCAGTATATGGA-1 pbmc10k 860 350 44.1860465 ## AAACCCAGTATCGTAC-1 pbmc10k 1548 729 0.4521964 ## AAACCCAGTCGGTGAA-1 pbmc10k 6387 1827 10.4117739 ## AAACCCAGTTAGAAAC-1 pbmc10k 16664 3744 5.2808449 ## AAACCCAGTTATCTTC-1 pbmc10k 3352 1464 13.8424821 We can visualize the nFeature_RNA, nCount_RNA and percent.mt we used for QC metrics # Visualize QC metrics as a violin plot VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) We can then using dot plot to show the relationship between nCount_RNA, nFeature_RNA and percent.mt. # FeatureScatter is typically used to visualize feature-feature relationships, but can be used # for anything calculated by the object, i.e. columns in object metadata, PC scores etc. plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) + theme(legend.position=&quot;none&quot;) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + theme(legend.position=&quot;none&quot;) plot1 + plot2 Here, we filter cells that have unique feature counts over 5,000 or less than 200. We also filter cells that have &gt;15% mitochondrial counts pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 5000 &amp; percent.mt &lt; 15) We can visualize QC metrics again after filtering cells VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) + theme(legend.position=&quot;none&quot;) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + theme(legend.position=&quot;none&quot;) plot1 + plot2 3.3.2 Normalizing the data After removing unwanted cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method LogNormalize that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in pbmc[[\"RNA\"]]@data. pbmc &lt;- NormalizeData(pbmc, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000, verbose = FALSE) For clarity, in this previous line of code (and in future commands), we provide the default values for certain parameters in the function call. However, this isnt required and the same behavior can be achieved with: pbmc &lt;- NormalizeData(pbmc) 3.3.3 Identification of highly variable features (feature selection) We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). We and others(Brennecke et al. 2013) have found that focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. Our procedure in Seurat is described in detail here(Stuart et al. 2019), and improves on previous versions by directly modeling the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, we return 2,000 features per dataset. These will be used in downstream analysis, like PCA. pbmc &lt;- FindVariableFeatures(pbmc, selection.method = &quot;vst&quot;, nfeatures = 2000, verbose = FALSE) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(pbmc), 10) # plot variable features with and without labels plot1 &lt;- VariableFeaturePlot(pbmc) + theme(legend.position=&quot;none&quot;) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) plot1 + plot2 3.3.4 Scaling the data Next, we apply a linear transformation (scaling) that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function: Shifts the expression of each gene, so that the mean expression across cells is 0 Scales the expression of each gene, so that the variance across cells is 1 This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate The results of this are stored in pbmc[[\"RNA\"]]@scale.data all.genes &lt;- rownames(pbmc) pbmc &lt;- ScaleData(pbmc, features = all.genes, verbose = FALSE) Using the above command, we use all genes to scale data. Scaling is an essential step in the Seurat workflow, but only on genes that will be used as input to PCA. Therefore, the default in ScaleData() is only to perform scaling on the previously identified variable features (2,000 by default). And it will make this step faster. In this case, your PCA and clustering results will be unaffected. However, Seurat heatmaps (produced as shown below with DoHeatmap()) require genes in the heatmap to be scaled, to make sure highly-expressed genes dont dominate the heatmap. To make sure we dont leave any genes out of the heatmap later, we are scaling all genes in this tutorial. To do this, omit the features argument in the previous function call, i.e. pbmc &lt;- ScaleData(pbmc) In Seurat v2 we also use the ScaleData() function to remove unwanted sources of variation from a single-cell dataset. For example, we could regress out heterogeneity associated with (for example) cell cycle stage, or mitochondrial contamination. These features are still supported in ScaleData() in Seurat v3, i.e.: pbmc &lt;- ScaleData(pbmc, vars.to.regress = &quot;percent.mt&quot;) However, particularly for advanced users who would like to use this functionality, we strongly recommend the use of our new normalization workflow, SCTransform(). The method is described in Seurat paper(Hafemeister and Satija 2019), with a separate vignette using Seurat v3 here. As with ScaleData(), the function SCTransform() also includes a vars.to.regress parameter. 3.4 Perform linear dimensional reduction Next we perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to choose a different subset. pbmc &lt;- RunPCA(pbmc, features = VariableFeatures(object = pbmc), verbose = FALSE) Seurat provides several useful ways of visualizing both cells and features that define the PCA, including VizDimLoadings(), DimPlot(), and DimHeatmap(). # Examine and visualize PCA results a few different ways print(pbmc[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: LTB, IL32, TRAC, CD3D, TRBC2 ## Negative: FCN1, FGL2, CST3, IFI30, TYMP ## PC_ 2 ## Positive: MS4A1, CD79A, BANK1, IGHM, NIBAN3 ## Negative: IL32, GZMM, CD3D, CD7, CD247 ## PC_ 3 ## Positive: GZMB, CLIC3, NKG7, GNLY, KLRD1 ## Negative: CCR7, LEF1, TRABD2A, TCF7, LTB ## PC_ 4 ## Positive: CD79B, MS4A1, GNLY, CD79A, LINC00926 ## Negative: LILRA4, CLEC4C, SERPINF1, TPM2, SCT ## PC_ 5 ## Positive: CDKN1C, HES4, CTSL, TCF7L2, BATF3 ## Negative: S100A12, ITGAM, VCAN, CES1, MGST1 VizDimLoadings(pbmc, dims = 1:2, reduction = &quot;pca&quot;) DimPlot(pbmc, reduction = &quot;pca&quot;) In particular DimHeatmap() allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and features are ordered according to their PCA scores. Setting cells to a number plots the extreme cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, we find this to be a valuable tool for exploring correlated feature sets. DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE) DimHeatmap(pbmc, dims = 1:9, cells = 500, balanced = TRUE) To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a metafeature that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. Here, we choose first 20 PCs. 3.5 Cluster the cells Seurat v3 applies a graph-based clustering approach, building upon initial strategies in(Macosko et al. 2015). Importantly, the distance metric which drives the clustering analysis (based on previously identified PCs) remains the same. However, our approach to partitioning the cellular distance matrix into clusters has dramatically improved. Our approach was heavily inspired by recent publications which applied graph-based clustering approaches to scRNA-seq data(Xu and Su 2015) and CyTOF data(Levine et al. 2015). Briefly, these methods embed cells in a graph structure - for example a K-nearest neighbor (KNN) graph, with edges drawn between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected quasi-cliques or communities. As in PhenoGraph, we first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset (first 10 PCs). To cluster the cells, we next apply modularity optimization techniques such as the Louvain algorithm (default) or SLM(Blondel et al. 2008), to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the granularity of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters can be found using the Idents() function. pbmc &lt;- FindNeighbors(pbmc, dims = 1:20, verbose = FALSE) pbmc &lt;- FindClusters(pbmc, resolution = 0.5, verbose = FALSE) # Look at cluster IDs of the first 5 cells head(Idents(pbmc), 5) ## AAACCCAGTATCGTAC-1 AAACCCAGTCGGTGAA-1 AAACCCAGTTAGAAAC-1 AAACCCAGTTATCTTC-1 AAACCCAGTTGCCGAC-1 ## 2 4 2 8 0 ## Levels: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 3.6 Run non-linear dimensional reduction (UMAP/tSNE) Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP and tSNE, we suggest using the same PCs as input to the clustering analysis. pbmc &lt;- RunUMAP(pbmc, dims = 1:20, verbose = FALSE) ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session Then we can get the UMAP plot of the single cell clustering results. DimPlot(pbmc, reduction = &quot;umap&quot;) We can also visualize it using tSNE plot pbmc &lt;- RunTSNE(pbmc, dims = 1:20, verbose = FALSE) DimPlot(pbmc, reduction = &quot;tsne&quot;) We can set label = TRUE or use the LabelClusters function to help label individual clusters. DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE) plot &lt;- DimPlot(object = pbmc) LabelClusters(plot = plot, id = &#39;ident&#39;) Now it is time to save the object so that it can easily be loaded back in without having to rerun the computationally intensive steps performed above, or easily shared with collaborators. saveRDS(pbmc, file = &quot;./data/pbmc_processed.rds&quot;) References "],["references.html", "References", " References "]]
